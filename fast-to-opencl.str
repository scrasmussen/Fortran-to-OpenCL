//------------------------------------------------------------------
// Open Fortran Project
// December 2014
// Create by Soren Rasmussen
// fortran-to-opencl.str
//------------------------------------------------------------------

module fast-to-opencl

imports
   libstratego-lib
   FAST

signature
  constructors

    TEST: A * B  -> TEST
    Mult: A * B  -> Mult
    Plus: A * B  -> Plus
    PartRef: A * B * C -> PartRef
    AssignmentStmt: A * B * C * D -> AssignmentStmt    
    OfpExecPart: A -> OfpExecPart
    OfpSubroutine: A * B -> OfpSubroutine
    OfpScope: A * B * C * D * E * F -> OfpScope
    OfpProgram: A * B -> OfpProgram

    Mul:  A * B  -> Mul
    Add:  A * B  -> Add
    Subt: A * B  -> Subt
    ArrayIndex: A * B -> ArrayIndex    
    IntConst: A -> IntConst
    Id: A -> Id
    Negative: A -> Negative
    Positive: A -> Positive
    FloatConst: A -> FloatConst
    Assign: A * B * C -> Assign
    AssignEq: AssignEq
    Stat: A -> A
    Compound: A * B -> Compound
    TypeSpec: A * B * C -> TypeSpec
    IdDecl: A * B * C -> IdDecl
    Some: A -> Some
    ParamList: A -> ParamList
    Void: Void
    FunDef: A * B * C -> FunDef   
    TranslationUnit: A -> TranslationUnit


strategies //=================START OF STRATEGIES==========================

io-fast-to-opencl-NOTWORKING = io-wrap(
              ArgOption(
                 "-n"
                 , where(<extend-config> ("-n", [<id>]))
                 , !"-n               Binding name to be selected")
              , fast-to-opencl-usage
              , fast-to-opencl-about
              , fast-to-opencl-start
	      //, fast-to-opencl-end
	      )

fast-to-opencl-usage =
    default-system-usage(
      !["Usage: fast-to-opencl -n binding_name"]
    , !["\n   This program generates an OpenCL AST from a Fortran AST (FAST).\n"]
    )

fast-to-opencl-about =
    <echo> "Written by Soren Rasmussen <soren.rasmussen@aggiemail.usu.edu>"

fast-to-opencl-start =
{ st
   :  debug(!"START: ")
   ; new-hashtable => st  
//    ; innermost(fast-to-opencl)
   ;  debug(!"FINISHED: ")
}

fast-to-opencl-end =
     debug(!"START-END: ")
//  ;  topdown(fast-to-opencl-finish)
  ;  debug(!"FINISHED-END: ")

io-fast-to-opencl =
  io-wrap(fast-to-opencl)

fast-to-opencl =
{ st
   : ?OfpProgram(name, units)
   ; new-hashtable => st  
   ; !OfpProgram(name, units)
   ; debug(!"HELLO ")
   ; topdown(try(fast-get-symbols(|st)))
   ; <hashtable-keys> st
   ; debug(!"KEYS:------- ")
   ; <hashtable-values> st
   ; debug(!"VALS:------- ")
   ; !OfpProgram(name, units)
//   ;debug(!"AFTER_ST:-------")
//   ; innermost(fast-to-opencl)
//   ;  debug(!"FINISHED: ")
}




TypeSpec = !TypeSpec([],Void(),[])
IdDecl = ?name; !IdDecl([], Id(name), Some(ParamList([])))

rules //=================================RULES=====================================

// Build Symbol Table

// Add declared variables to symbol table
fast-get-symbols(|st) =
     ?TypeDeclarationStmt(label,type,attrs,vars,eos)
  ;  <map(st-add-symbol(|st,type,attrs))><map(ofp-ident)>vars 
  ;  !TypeDeclarationStmt(label,type,attrs,vars,eos)

// Update symbol table with information from allocate statements
//fast-get-symbols(|st) =
//     ?AllocateStmt(label,type,alloc_list,options,eos)
//  ;  <map(fast-update-allocation-symbol(|st))> alloc_list
//  ;  !AllocateStmt(label,type,alloc_list,options,eos)



// Add a symbol to the symbol table
st-add-symbol(|st,type,attrs) =
     ?symbol
  ;  <hashtable-put(|symbol,(type,attrs))> st

ofp-ident
  :  EntityDecl(ident,_,_,_,_) -> ident

fast-update-allocation-dim =
     ?(AllocateShapeSpec(lb,ub),DimSpec(_,_))
  ;  !DimSpec(lb,ub)


// unary and binary operators
fast-to-opencl :  Mult(expr1, expr2)  ->  Mul(expr1, expr2)
fast-to-opencl :  Plus(expr)          ->  Positive(expr)
fast-to-opencl :  Minus(expr)         ->  Negative(expr)
fast-to-opencl :  Plus(expr1, expr2)  ->  Add(expr1, expr2)
fast-to-opencl :  Minus(exprl,expr2)  ->  Subt(exprl,expr2)

// Array index
fast-to-opencl = 
      ?PartRef(name, [index], something)
   ;  !ArrayIndex(Id(name), index)

  <+  ?RealLiteralConstant(num, _)
   ;  !FloatConst(num)

fast-to-opencl = 
   // Possibly edit for better functionality 
      ?AssignmentStmt(_, left, right, _)
   ;  !Stat(Assign(left, AssignEq(), right))

  <+  ?OfpExecPart(list)
   ;  !Compound([],list)

//  <+  ?OfpSubroutine(name, scope)
//   ;  !FunDef(<TypeSpec>, <IdDecl>name, scope)

//  <+  ?OfpScope(_, exec, _, _, _, _)
//   ;  ![exec]

  <+  ?OfpProgram(_, body)
   ;  !TranslationUnit(body)



// NOT WORKING and currently NOT USED
fast-to-opencl1 =
  // Fixing Array indexing
      ?ArrayIndex(name1, Negative(index))
   ;  !ArrayIndex(name1, Negative(IntConst(index)))

  <+  ?ArrayIndex(name1, Positive(index))
   ;  !ArrayIndex(name1, Positive(IntConst(index)))

  <+  ?ArrayIndex(name1, index)
   ;  !ArrayIndex(name1, IntConst(index))

  //fast-to-opencl: Minus(expr) -> Negative(IntConst(expr))
  //fast-to-opencl: Plus(expr)  -> Positive(IntConst(expr))
